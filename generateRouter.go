// Package ginGenRouter Gin router file generate
// Copyright 2024 F.W
// License: MIT License
// Auto generate routers from gin controller comments and generate router code to file
// This file is generated by the code generator.
package ginGenRouter

import (
	"encoding/json"
	"errors"
	"fmt"
	"go/ast"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"unicode"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

var (
	genInfoList      map[string][]ControllerComments
	routeRegex       = regexp.MustCompile(`@Router\s+(\S+)(?:\s+\[(\S+)\])?`)
	summaryRegex     = regexp.MustCompile(`@Summary\s+(.*)`)
	descriptionRegex = regexp.MustCompile(`^[^@]+(.*)`)
)

type ControllerComments struct {
	methodName       string
	Router           string                 `json:"router"`
	AllowHTTPMethods []string               `json:"allowHttpMethods"`
	ControllerName   string                 `json:"-"`
	PackageName      string                 `json:"-"`
	Summary          string                 `json:"summary"`
	Params           map[string]parsedParam `json:"params"`
	Description      string                 `json:"description"`
}
type parsedComment struct {
	RouterPath  string                 `json:"routerPath"`
	Methods     []string               `json:"methods"`
	Params      map[string]parsedParam `json:"params"`
	Summary     string                 `json:"summary"`
	Description string                 `json:"description"`
}

type parsedParam struct {
	name        string
	DataType    string `json:"dataType"`
	Location    string `json:"location"`
	DefValue    string `json:"defValue"`
	Required    bool   `json:"required"`
	Description string `json:"summary"`
}

// GenRouters generates routers from gin controller comments and generate router code to file
// controllersPath: the path of the controllers package directory
// routersPath: the path of the routers package directory
func GenRouters(controllersPath, routersPath string) {
	if len(controllersPath) == 0 {
		controllersPath = "./controllers"
	}
	if len(routersPath) == 0 {
		routersPath = "routers"
	}
	err := parserPkg(controllersPath, routersPath)
	if err != nil {
		//fmt.Printf("parserPkg error:%s \n", err)
		fmt.Errorf("parse file failed, format: JSON, %w", err)
		return
	}
}

// parserPkg parses the package and documents
func parserPkg(ctrlPath string, routersPath string) error {
	genInfoList = make(map[string][]ControllerComments)
	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedCompiledGoFiles | packages.NeedSyntax,
		Dir:  ctrlPath,
	}, "./...")

	if err != nil {
		return err
	}
	for _, pkg := range pkgs {
		for _, fl := range pkg.Syntax {
			for _, d := range fl.Decls {
				switch specDecl := d.(type) {
				case *ast.FuncDecl:
					if specDecl.Recv != nil {
						exp, ok := specDecl.Recv.List[0].Type.(*ast.StarExpr) // Check that the type is correct first beforing throwing to parser
						if ok {
							err = parserComments(specDecl, fmt.Sprint(exp.X), pkg.PkgPath)
							if err != nil {
								return err
							}
						}
					}
				}
			}
		}
	}
	return genRouterCode(routersPath)
}

func parserComments(f *ast.FuncDecl, controllerName, pkgPath string) error {
	if f.Doc != nil {
		parsedComments, err := parseComment(f.Doc.List)
		if err != nil {
			return err
		}

		for _, parsedComment := range parsedComments {
			if parsedComment.RouterPath != "" {
				key := pkgPath + ":" + controllerName
				cc := ControllerComments{}
				cc.methodName = f.Name.String()
				cc.Router = parsedComment.RouterPath
				cc.AllowHTTPMethods = parsedComment.Methods
				cc.ControllerName = controllerName
				cc.PackageName = pkgPath
				cc.Summary = parsedComment.Summary
				cc.Description = parsedComment.Description
				cc.Params = parsedComment.Params
				genInfoList[key] = append(genInfoList[key], cc)
			}
		}
	}
	return nil
}

// parseComment parses the comment lines and returns the parsed comment
func parseComment(lines []*ast.Comment) (pcs []*parsedComment, err error) {
	//@Param  id   path      int  true  "Account ID"
	pcs = []*parsedComment{}
	params := map[string]parsedParam{}
	const doubleSlash = "/"
	for _, c := range lines {
		t := strings.TrimSpace(strings.TrimLeft(c.Text, doubleSlash))
		const paramPrefix = "@Param"
		if strings.HasPrefix(t, paramPrefix) {
			pv := getparams(strings.TrimSpace(strings.TrimPrefix(t, paramPrefix)))
			if len(pv) < 3 {
				fmt.Println("Invalid @Param format. Needs at least 3 parameters")
			}
			p := parsedParam{}
			names := strings.SplitN(pv[0], "=>", 2)
			p.name = names[0]
			funcParamName := p.name
			if len(names) > 1 {
				funcParamName = names[1]
			}
			p.Location = pv[1]
			p.DataType = pv[2]
			switch len(pv) {

			case 5:
				p.Required, _ = strconv.ParseBool(pv[3])
				p.DefValue = pv[4]
			case 6:
				p.DefValue = pv[4]
				p.Required, _ = strconv.ParseBool(pv[3])
				p.Description = pv[5]
			}
			params[funcParamName] = p
		}
	}
	var summary string
	var description string
	for _, c := range lines {
		t := strings.TrimSpace(strings.TrimLeft(c.Text, doubleSlash))
		if strings.HasPrefix(t, "@Summary") {

			match := summaryRegex.FindStringSubmatch(t)
			if len(match) == 2 {
				summary = match[1]
			}

		}
		matchDesc := descriptionRegex.FindStringSubmatch(t)
		if len(matchDesc) == 2 {
			description += matchDesc[0] + " "
		}

	}
	for _, c := range lines {
		var pc = &parsedComment{}
		pc.Params = params
		t := strings.TrimSpace(strings.TrimLeft(c.Text, doubleSlash))
		pc.Description = description
		pc.Summary = summary
		if strings.HasPrefix(t, "@Router") {
			//t := strings.TrimSpace(strings.TrimLeft(c.Text, doubleSlash))

			matches := routeRegex.FindStringSubmatch(t)
			if len(matches) == 3 {
				pc.RouterPath = matches[1]
				methods := matches[2]
				if methods == "" {
					pc.Methods = []string{"get"}
				} else {
					pc.Methods = strings.Split(methods, ",")
				}
				pcs = append(pcs, pc)
			} else {
				return nil, errors.New("router information is missing")
			}
		}
	}
	return
}

// @Param	query		form	 string	true		"The email for login"
// parse the @Param line
func getparams(str string) []string {
	var s []rune
	var j int
	var start bool
	var r []string
	var quoted int8
	for _, c := range str {
		if unicode.IsSpace(c) && quoted == 0 {
			if !start {
				continue
			} else {
				start = false
				j++
				r = append(r, string(s))
				s = make([]rune, 0)
				continue
			}
		}

		start = true
		if c == '"' {
			quoted ^= 1
			continue
		}
		s = append(s, c)
	}
	if len(s) > 0 {
		r = append(r, string(s))
	}
	return r
}

// genRouterCode generates router code to file
func genRouterCode(routersPath string) error {
	var (
		sortKey []string
	)
	for k := range genInfoList {
		sortKey = append(sortKey, k)
	}
	sort.Strings(sortKey)

	f := jen.NewFile(routersPath)
	f.PackageComment("Package routers is a package for routing the requests to the appropriate handler functions.")
	f.Func().Id("RegisterRoutes").Params(jen.Id("routerGroup").Op("*").Qual("github.com/gin-gonic/gin", "RouterGroup")).BlockFunc(func(g *jen.Group) {
		for _, k := range sortKey {
			cList := genInfoList[k]
			kList := strings.Split(k, ":")
			nameSpace := strings.ToLower(kList[1][:1]) + kList[1][1:]
			g.Id(nameSpace).Op(":=").Qual(kList[0], kList[1]).ValuesFunc(func(g *jen.Group) {})

			for _, c := range cList {

				for _, method := range c.AllowHTTPMethods {
					g.Comment(c.Summary)
					//jsonByte, _ := json.MarshalIndent(c.Params, "", "  ")
					//g.Comment(string(jsonByte))
					g.Id("routerGroup").Dot(strings.ToUpper(method)).Call(jen.Lit(c.Router), jen.Id(nameSpace).Dot(c.methodName))

				}

			}
		}

	})

	_, err := os.Stat(routersPath)
	if err != nil {
		if os.IsNotExist(err) {
			os.Mkdir(routersPath, os.ModePerm)
		}
	}
	routerFile := routersPath + "/autoGenRouter.go"
	routerJsonFile := routersPath + "/autoGenRouter.json"
	//fmt.Printf("%#v", f)
	err = f.Save(routerFile)
	if err != nil {
		return err
	}
	// generate router json file use view
	var routerList []ControllerComments
	for _, k := range sortKey {
		cList := genInfoList[k]
		routerList = append(routerList, cList...)
	}
	if routerList == nil {
		return nil
	}
	jsonBytes, err := json.MarshalIndent(routerList, "", "  ")
	os.WriteFile(routerJsonFile, jsonBytes, 0644)
	return err
}
